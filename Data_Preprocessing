# preprocess.py
import modal

app = modal.App("weather-preprocessing")

# Create an image with your required Python libraries
image = (
    modal.Image.debian_slim()
    .pip_install(
        "pandas",
        "numpy",
        "scikit-learn"
    )
)

@app.function(image=image, timeout=600)
def run_preprocessing():
    import pandas as pd
    import numpy as np
    from sklearn.preprocessing import StandardScaler

    print("Loading dataset...")

    df = pd.read_csv("/data/gallipoli_weather.csv")

    # ----- PREPROCESSING -----
    df['DateTime'] = pd.to_datetime(df['DateTime'], format="%d.%m.%Y %H:%M")
    df = df.sort_values("DateTime").reset_index(drop=True)
    df.interpolate(method='linear', inplace=True)

    # Extract datetime features
    df["year"] = df["DateTime"].dt.year
    df["month"] = df["DateTime"].dt.month
    df["day"] = df["DateTime"].dt.day
    df["hour"] = df["DateTime"].dt.hour
    df["dayofweek"] = df["DateTime"].dt.dayofweek
    df["dayofyear"] = df["DateTime"].dt.dayofyear

    df["hour_sin"] = np.sin(2 * np.pi * df["hour"] / 24)
    df["hour_cos"] = np.cos(2 * np.pi * df["hour"] / 24)
    df["doy_sin"] = np.sin(2 * np.pi * df["dayofyear"] / 365)
    df["doy_cos"] = np.cos(2 * np.pi * df["dayofyear"] / 365)

    df.dropna(inplace=True)

    # Feature & target selection
    feature_cols = [
        'Temperature', 'Relative Humidity', 'Wind Speed', 'Wind Direction',
        'Soil Temperature', 'Soil Moisture',
        'year','month','day','hour','dayofweek','dayofyear',
        'hour_sin','hour_cos','doy_sin','doy_cos'
    ]

    target_cols = [
        'Temperature', 'Relative Humidity', 'Wind Speed',
        'Wind Direction', 'Soil Temperature', 'Soil Moisture'
    ]

    data = df[feature_cols].copy()

    # Scale features
    scaler = StandardScaler()
    scaled_data = scaler.fit_transform(data)
    scaled_data = pd.DataFrame(scaled_data, columns=feature_cols)

    # Sliding window
    INPUT_WINDOW = 240
    OUTPUT_WINDOW = 168

    def create_windows(data, input_len, output_len, target_cols):
        X, Y = [], []
        total_len = input_len + output_len

        for i in range(len(data) - total_len):
            past = data.iloc[i : i + input_len].values
            future = data.iloc[i + input_len : i + total_len][target_cols].values
            X.append(past)
            Y.append(future)

        return np.array(X), np.array(Y)

    X, Y = create_windows(scaled_data, INPUT_WINDOW, OUTPUT_WINDOW, target_cols)

    print("Saving output...")
    np.save("/data/X.npy", X)
    np.save("/data/Y.npy", Y)

    print("Done! Shapes:")
    print("X:", X.shape)
    print("Y:", Y.shape)
